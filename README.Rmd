---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit README.Rmd -->



```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# qtl2pleio <img src="https://raw.githubusercontent.com/fboehm/qtl2pleio/master/man/figures/logo.png" align="right" />

[![Binder](http://mybinder.org/badge_logo.svg)](http://mybinder.org/v2/gh/fboehm/qtl2pleio/master?urlpath=rstudio)
[![Travis-CI Build Status](https://travis-ci.org/fboehm/qtl2pleio.svg?branch=master)](https://travis-ci.org/fboehm/qtl2pleio)
[![Coverage Status](https://img.shields.io/codecov/c/github/fboehm/qtl2pleio/master.svg)](https://codecov.io/github/fboehm/qtl2pleio?branch=master)
[![Project Status: WIP â€“ Initial development is in progress, but there has not yet been a stable, usable release suitable for the public.](https://www.repostatus.org/badges/latest/wip.svg)](https://www.repostatus.org/#wip)




## Goals

The goal of qtl2pleio is, for a pair of traits that show evidence for
a QTL in a common region, to distinguish between pleiotropy (the null
hypothesis, that they are affected by a common QTL) and the
alternative that they are affected by separate QTL. It extends the
likelihood ratio test of [Jiang and Zeng
(1995)](http://www.genetics.org/content/140/3/1111.long) for
multiparental populations, such as Diversity Outbred mice, including
the use of a linear mixed model to account for population structure.
`qtl2pleio` data structures are those used in the
[`rqtl/qtl2`](https://kbroman.org/qtl2) package.


## Installation


To install qtl2pleio, use `install_github()` from the
[devtools](https://devtools.r-lib.org) package.


```{r, eval = FALSE}
install.packages("devtools")
devtools::install_github("fboehm/qtl2pleio")
```

You may also wish to install [R/qtl2](https://kbroman.org/qtl2) and
the [`qtl2convert`](https://github.com/rqtl/qtl2convert) package. We
will use both below.

```{r, eval = FALSE}
install.packages(c("qtl2", "qtl2convert"), repos="http://rqtl.org/qtl2")
```


## Example

Below, we walk through an example analysis with Diversity Outbred
mouse data. We need a number of preliminary steps before we can
perform our test of pleiotropy vs. separate QTL. Many procedures rely
on the R package `qtl2`. We first load the `qtl2`, `qtl2convert`,
and `qtl2pleio` packages.

```{r}
library(qtl2)
library(qtl2convert)
library(qtl2pleio)
```


### Reading data from `qtl2data` repository on github

We'll consider the
[`DOex`](https://github.com/rqtl/qtl2data/tree/master/DOex) data in
the [`qtl2data`](https://github.com/rqtl/qtl2data) repository.
We'll download the pre-calculated allele probabilities.

```{r}
tmpfile <- tempfile()
file <- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/master/DOex/DOex_alleleprobs.rds")
download.file(file, tmpfile)
pr <- readRDS(tmpfile)
unlink(tmpfile)
```

And then we'll download the physical marker map and convert it to a
R/qtl2 map object.

```{r}
tmpfile <- tempfile()
file <- paste0("https://raw.githubusercontent.com/rqtl/",
               "qtl2data/master/DOex/DOex_pmap.csv")
download.file(file, tmpfile)
pmap_pre <- read.csv(tmpfile)
unlink(tmpfile)
pm <- qtl2convert::map_df_to_list(pmap_pre, pos_column="pos")
```

We now have an allele probabilities object stored in `pr`.

```{r}
names(pr)
dim(pr$`2`)
```

We see that `pr` is a list of 3 three-dimensional arrays - one array for each of 3 chromosomes.

### Kinship calculations

For our statistical model, we need a kinship matrix. Although we don't have genome-wide data - since we have allele probabilities for only 3 chromosomes - let's calculate a kinship matrix using "leave-one-chromosome-out". In practice, one would want to use allele probabilities from a full genome-wide set of markers.

```{r}
calc_kinship(probs = pr, type = "loco") -> kinship
```

```{r}
str(kinship)
```

We see that `kinship` is a list containing 3 matrices. Each matrix is 261 by 261 - where the number of subjects is 261 - and symmetric. The $(i, j)$ cell in the matrix contains the estimate of identity-by-state (IBS) probability for randomly chosen alleles at a single locus for those two subjects.




Before we simulate phenotype data, we first specify our statistical model.

We use the model:

$$vec(Y) = X vec(B) + vec(G) + vec(E)$$

where $Y$ is a $n$ by $2$ matrix, where each row is one subject and each column is one quantitative trait. $X$ is a $2n$ by $2f$ design matrix containing $n$ by $f$ allele probabilities matrices for each of two (possibly identical) markers. Thus, $X$ is a block-diagonal matrix, with exactly two $n$ by $f$ blocks on the diagonal. $B$ is a $f$ by 2 matrix. "vec" refers to the vectorization operator. "vec(B)", where $B$ is a $f$ by $2$ matrix, is, thus, a (column) vector of length $2f$ that is formed by stacking the second column of $B$ beneath the first column of $B$.

$G$ is a matrix of random effects. We specify its distribution as matrix-variate normal with mean being a $n$ by $2$ matrix of zeros, covariance among row vectors a $n$ by $n$ kinship matrix, $K$, and covariance among column vectors a $2$ by $2$ genetic covariance matrix, $V_g$.

In mathematical notation, we write:

$$G \sim MN_{\text{n by 2}}(0, K, V_g)$$

We also need to specify the distribution of the $E$ matrix, which contains the random errors. $E$ is a random $n$ by $2$ matrix that is distributed as a matrix-variate normal distribution with mean being the $n$ by $2$ zero matrix, covariance among row vectors $I_n$, the $n$ by $n$ identity matrix, and covariance among columns the $2$ by $2$ matrix $V_e$.

$$E \sim MN_{\text{n by 2}}(0, I_n, V_e)$$



In practice, we typically observe the phenotype matrix $Y$. We also treat as known the design matrix $X$ and the kinship matrix $K$. We then infer the values of $B$, $V_g$, and $V_e$.



### Simulating phenotypes with `qtl2pleio::sim1`


The function to simulate phenotypes in `qtl2pleio` is `sim1`. By examining its help page, we see that it takes five arguments. The help page also gives the dimensions of the inputs.

```{r}
# set up the design matrix, X
pp <- pr[[2]]
X <- gemma2::stagger_mats(pp[ , , 50], pp[ , , 50])
# assemble B matrix of allele effects
B <- matrix(data = c(-1, -1, -1, -1, 1, 1, 1, 1, -1, -1, -1, -1, 1, 1, 1, 1), nrow = 8, ncol = 2, byrow = FALSE)
# verify that B is what we want:
B
# set.seed to ensure reproducibility
set.seed(2018-01-30)
# call to sim1
Ypre <- sim1(X = X, B = B, Vg = diag(2), Ve = diag(2), kinship = kinship[[2]])
Y <- matrix(Ypre, nrow = 261, ncol = 2, byrow = FALSE)
rownames(Y) <- rownames(pp)
colnames(Y) <- c("tr1", "tr2")
```

Let's perform univariate QTL mapping for each of the two traits in the Y matrix.

```{r}
scan1(genoprobs = pr, pheno = Y, kinship = kinship) -> s1
```

```{r}
plot(s1, pm)
```


```{r}
find_peaks(s1, map = pm)
```





### Perform two-dimensional scan as first step in pleiotropy v separate QTL hypothesis test


```{r}
out <- scan_pvl(probs = pp,
                pheno = Y,
                kinship = kinship[[2]], # 2nd entry in kinship list is Chr 3
                start_snp = 38,
                n_snp = 25, n_cores = 1
                )
```


#### Create a profile LOD plot to visualize results of two-dimensional scan

```{r}
library(dplyr)
out %>%
  tidy_scan_pvl(pm3) %>% # pm3 is physical map for Chr 3
  add_intercepts(intercepts_univariate = c(82.8, 82.8)) %>%
  plot_pvl(phenames = c("tr1", "tr2"))

```


#### Calculate the likelihood ratio test statistic for pleiotropy v separate QTL

We use the function `calc_lrt_tib` to calculate the likelihood ratio test statistic value for the specified traits and specified genomic region.

```{r}
(calc_lrt_tib(out) -> lrt)
```

### Bootstrap analysis to get p-values

The calibration of test statistic values to get p-values uses bootstrap methods because we don't know the theoretical distribution of the test statistic under the null hypothesis. Thus, we use a bootstrap approach to obtain an empirical distribution of test statistic values under the null hypothesis of the presence of one pleiotropic locus.

We will use the function `boot_pvl` from our package `qtl2pleio`.

We use a parametric bootstrap strategy in which we first use the studied phenotypes to infer the values of model parameters. Once we have the inferred values of the model parameters, we simulate phenotypes from the pleiotropy model (with the inferred parameter values).


A natural question that arises is "which marker's allele probabilities do we use when simulating phenotypes?" We use the marker that, under the null hypothesis, ie, under the pleiotropy constraint, yields the greatest value of the log-likelihood.

Before we call `boot_pvl`, we need to identify the index (on the chromosome under study) of the marker that maximizes the likelihood under the pleiotropy constraint. To do this, we use the `qtl2pleio` function `find_pleio_peak_tib`.

```{r}
(pleio_index <- find_pleio_peak_tib(out, start_snp = 38))
```




```{r}
set.seed(2018-11-25)
system.time(b_out <- boot_pvl(probs = pp,
         pheno = Y,
         pleio_peak_index = pleio_index,
         kinship = kinship[[2]], # 2nd element in kinship list is Chr 3
         nboot_per_job = 10,
         start_snp = 38,
         n_snp = 25
         ))

```


The argument `nboot_per_job` indicates the number of bootstrap samples that will be created and analyzed. Here, we set `nboot_per_job = 10`, so we expect to see returned a numeric vector of length 10, where each entry is a LRT statistic value from a distinct bootstrap sample.

Finally, we determine a bootstrap p-value in the usual method. We treat the bootstrap samples' test statistics as an empirical distribution of the test statistic under the null hypothesis of pleiotropy. Thus, to get a p-value, we want to ask "What is the probability, under the null hypothesis, of observing a test statistic value that is at least as extreme as that which we observed?"

```{r}
b_out
(pvalue <- mean(b_out >= lrt))
```

In practice, one would want to use many more bootstrap samples to achieve an empirical distribution that is closer to the theoretical distribution of the test statistic under the null hypothesis.

However, if one wants to perform analyses with a reasonable number - say 400 - bootstrap samples, this will take a very long time - many days - on a single laptop computer. We have used a series of computer clusters that are coordinated by the University of Wisconsin-Madison's Center for High-throughput Computing (http://chtc.cs.wisc.edu). We typically are able to analyze 1000 bootstrap samples in less than 24 hours with this service.





## Code of Conduct
Please note that this project is released with a [Contributor Code of Conduct](CONDUCT.md). By participating in this project you agree to abide by its terms.

## Citation information

```{r}
citation("qtl2pleio")
```

Icon image of mice: https://www.jax.org/~/media/JaxWeb/images/jax-mice-and-services/mice/datasheets/002468

Icon image of Arabidopsis: https://sites.cns.utexas.edu/sites/default/files/styles/os_files_large/public/juenger_lab/files/pp1244cvr001-1.gif

Icon image of Drosophila: https://www.yourgenome.org/sites/default/files/styles/banner/public/banners/stories/fruit-flies-in-the-laboratory/single-fruit-fly-drosophila-melanogaster-on-white-background-cropped.jpg
